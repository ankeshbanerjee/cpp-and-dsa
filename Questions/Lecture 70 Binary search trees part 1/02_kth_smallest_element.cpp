#include <iostream>
using namespace std;

class Node {
    public:
    int data;
    Node * left;
    Node * right;

    Node (int data){
        this->data = data;
        this->left = NULL;
        this->right = NULL;
    }
};

int solve (Node * root, int k, int &i){

    // we will be doing inorder traversal
    // bcz, kth smallest element will be the kth element of the array generated by inorder traversal

    // base case
    if (root == NULL)
        return -1;

    // searching in left part (L)
    int left = solve(root->left, k, i);

    // found in left part
    if (left != -1)
        return left;

    // check if the current node is the result or not (N)
    i++;
    if (i==k)
        return root->data;

    // else, search in right part (R)
    return solve(root->right, k, i);

}

int kthSmallest (Node * root, int k){
    int i=0; 
    int ans = solve (root, k, i);
    return ans;
}

// TC = O(N) and SC = O(H)
// we can optimize space with using O(1) auxiliary space, by using morris traversal

int kSmallestUsingMorris (Node * root, int k){
    if (root == NULL)
        return -1;

    int count = 0;
    Node * curnt = root;

    while (curnt != NULL){
        // if left subtree doesn't exist
        if (curnt->left == NULL){
            count ++;
            if (count == k){
                return curnt->data;
            }
            curnt = curnt->right;
        }
        else{
            // find inorder predecessor
            Node * pred = curnt->left;
            if (pred->right != NULL && pred->right != curnt){
                pred = pred->right;
            }

            // linking predecessor to curnt
            if (pred->right == NULL){
                pred->right = curnt;
                curnt = curnt->left;
            }
            else{
                // breaking links to restore the tree as it was
                pred->right = NULL;
                count ++;
                if (count == k)
                    return curnt->data;
                curnt = curnt->right;
            }
        }
    }
}
// TC = O(N)
// SC = O(1)

// ** kth largest = (n-k)+1 th smallest


int main (){
/*  
    creating tree:
            10
           /   \
          8     12
         / \    / \
        5   9  11  15
       /   
      3    
*/
    
    Node * root = new Node (10);
    root->left = new Node (8);
    root->right = new Node (12);
    root->left->left = new Node (5);
    root->left->right = new Node (9);
    root->left->left->left = new Node (3);
    root->right->right = new Node (15);
    root->right->left = new Node (11);

    cout << "5th smallest element: " << kthSmallest(root, 5) << endl;
    cout << "5th smallest element: " << kSmallestUsingMorris(root, 5) << endl;
return 0;
}